# -*- coding: utf-8 -*-
"""script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Y2jPuR9SirR020ix6s3Fvku6zUekW4v

# üß† **Adding a Drawdown per Asset**

**Drawdown** measures how much an investment **falls from its peak** before recovering. It‚Äôs a risk metric, showing the pain investors might feel during market drops.

Think of it like this:

    ‚ÄúFrom the highest point so far, how much have I lost?‚Äù
"""

import pandas as pd
import numpy as np
import random

# --- Config ---
NUM_ASSETS = 5
NUM_DAYS = 60
SEED = 42
np.random.seed(SEED)
random.seed(SEED)

# --- Step 1: Simulate asset data ---
def generate_asset_data():
    tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA'][:NUM_ASSETS]
    start_price = 100
    date_range = pd.date_range(end=pd.Timestamp.today(), periods=NUM_DAYS, freq='B')

    records = []
    for ticker in tickers:
        price = start_price
        for date in date_range:
            daily_return = np.random.normal(0.001, 0.02)
            price *= (1 + daily_return)
            records.append({
                'Date': date,
                'Ticker': ticker,
                'Sector': random.choice(['Tech', 'Consumer', 'Auto']),
                'Asset Class': 'Equity',
                'Region': random.choice(['US', 'Global']),
                'Closing Price': round(price, 2),
                'Daily Return': round(daily_return, 5),
                'Portfolio Weight': round(1/NUM_ASSETS, 2)
            })
    return pd.DataFrame(records)

# --- Step 2: Simulate benchmark (e.g., SPY) ---
def generate_benchmark():
    date_range = pd.date_range(end=pd.Timestamp.today(), periods=NUM_DAYS, freq='B')
    benchmark_price = 100 * np.cumprod(1 + np.random.normal(0.0008, 0.015, NUM_DAYS))
    benchmark_returns = np.diff(benchmark_price, prepend=benchmark_price[0]) / benchmark_price[:-1].mean()

    daily_rf = 0.0002  # Constant daily risk-free rate

    benchmark_df = pd.DataFrame({
        'Date': date_range,
        'Ticker': 'SPY',
        'Sector': 'Index',
        'Asset Class': 'Benchmark',
        'Region': 'US',
        'Closing Price': np.round(benchmark_price, 2),
        'Daily Return': np.round(benchmark_returns, 5),
        'Portfolio Weight': 0
    })

    # ‚úÖ Fix to propagate correctly during concat
    benchmark_df['Risk-Free Rate'] = [daily_rf] * len(benchmark_df)
    df['Risk-Free Rate'] = np.nan
    return benchmark_df

# --- Step 3: Drawdown calculation ---
def compute_drawdown(group):
    group = group.copy()
    cumulative = (1 + group['Daily Return']).cumprod()
    peak = cumulative.cummax()
    drawdown = (cumulative - peak) / peak
    group['Drawdown'] = drawdown
    return group

# --- Step 4: Generate data ---
df = generate_asset_data()
benchmark_df = generate_benchmark()

# Add blank risk-free rate column for alignment
df['Risk-Free Rate'] = np.nan

# --- Step 5: Compute drawdowns ---
df = df.groupby('Ticker', group_keys=False).apply(compute_drawdown)
benchmark_df = compute_drawdown(benchmark_df)

# --- Step 6: Combine full dataset ---
full_df = pd.concat([df, benchmark_df], ignore_index=True)

# Benchmark cumulative return
benchmark_df['Daily Return'] = benchmark_df['Daily Return'].pct_change()
benchmark_df['Cumulative Return'] = (1 + benchmark_df['Daily Return']).cumprod() - 1

# Merge benchmark cumulative return into full_df on date
full_df = full_df.merge(
    benchmark_df[['Date', 'Cumulative Return']].rename(columns={'Cumulative Return': 'Benchmark Cumulative Return'}),
    on='Date',
    how='left'
)

# Rolling Volatility
full_df['Rolling Volatility (21D)'] = (
    full_df.groupby('Ticker')['Daily Return'].transform(lambda x: x.rolling(window=21).std()) # .std = standard deviation of returns in that 21 D window
)

# Rolling Sharpe Ratio (21D)
# First, smoothen Risk-Free rate (21D rolling mean)
full_df['Rolling Risk-Free Rate(21D)'] = (
    full_df.groupby('Ticker')['Risk-Free Rate'].transform(lambda x: x.rolling(window=21).mean())
)

# Now compute rolling Sharpe Ratio
full_df['Rolling Sharpe Rate(21D)'] = (
    full_df.groupby('Ticker')['Daily Return'].transform(lambda x: x.rolling(window=21).mean())
    - full_df['Rolling Risk-Free Rate(21D)']
)/ full_df['Rolling Volatility (21D)']


"""# Creating excel file & processing"""

from openpyxl import load_workbook
from openpyxl.styles import PatternFill, Font, Alignment

# Export DataFrame to Excel
output_path = "Final_Portfolio_Analytics.xlsx"
full_df.to_excel(output_path, index=False)

# Load the Excel file just created
file_path = "Final_Portfolio_Analytics.xlsx"
wb = load_workbook(file_path)

# Select the active worksheet
ws = wb.active

# Auto-adjust column widths based on content
for columns in ws.columns:
  max_length = 0
  col_letter = columns[0].column_letter
  for cell in columns:
    try:
      if cell.value:
        max_length = max(max_length, len(str(cell.value)))
    except:
      pass
  ws.column_dimensions[col_letter].width = max_length + 2

# freeze header row
ws.freeze_panes = 'A2'

# Add autofilter to the top row
ws.auto_filter.ref = ws.dimensions

# Styling the header row
header_fill = PatternFill(start_color='DDDDDD', end_color='DDDDDD', fill_type = 'solid')
header_font = Font(bold=True)

for cell in ws[1]:
  cell.fill = header_fill
  cell.font = header_font
  cell.alignment = Alignment(horizontal='center')


# save it back
wb.save(file_path)
print("DONE")